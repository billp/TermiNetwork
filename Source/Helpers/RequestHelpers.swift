// RequestHelpers.swift
//
// Copyright Â© 2018-2022 Vassilis Panagiotopoulos. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in the
// Software without restriction, including without limitation the rights to use, copy,
// modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies
// or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FIESS FOR A PARTICULAR
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import Foundation

typealias RequestProcessReturnType = (data: Data?, tnError: TNError?)

/// Request helpers.
class RequestHelpers {
    /// Generates errors from generated by session task completion handler
    /// - Parameters:
    ///     - serverError: the error object from the completion handler
    /// - Returns:
    ///     - data: Data on success after middleware handler
    ///     - tnError: TNError on any generated error
    static func processData(with request: Request,
                            data: Data? = nil,
                            urlResponse: URLResponse?,
                            serverError: Error?) -> RequestProcessReturnType {
        var customError: TNError?
        var data = data

        /// Error handling
        if let error = serverError {
            if (error as NSError).code == NSURLErrorCancelled {
                if request.pinningErrorOccured {
                    customError = TNError.pinningError
                } else {
                    customError = TNError.cancelled(error)
                }
            } else {
                customError = TNError.networkError(error)
            }
        } else if let response = urlResponse as? HTTPURLResponse {
            let statusCode = response.statusCode
            if statusCode / 100 != 2 {
                customError = TNError.notSuccess(statusCode, data ?? .init())
            }
        }
      
        if customError == nil {
            do {
                data = try request.handleMiddlewareProcessResponseIfNeeded(responseData: data)
            } catch {
                if let error = error as? TNError {
                    customError = error
                }
            }
        }

        return RequestProcessReturnType(data: data, tnError: customError)
    }
}
